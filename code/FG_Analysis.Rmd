---
title: "Faville Grove Analysis"
author: "Kendall Beals"
date: "2023-02-28"
output:
  html_document: default
  pdf_document: default
---

**The project objectives and hypotheses will go here.**

First, install and/or load in the following packages. Multiple packages can be loaded simultaneously using the p_load function in the pacman package.  
```{r}
library(pacman)
p_load("fBasics", "rcompanion", "tidyverse", "metacoder", "vegan")
```


### Loading and formatting data 
```{r}
bact_count <- read_tsv("../data/FG_2022_Bact_ASV_counts_expanded.tsv")
bact_taxa <- read_tsv("../data/FG_Bact_Taxonomy_expanded.txt")
sample_data <- read_tsv("../data/Sample_metadata.txt")
```

Combine the taxa and count tables by matching the "ASV_ID" columns in both tables.
```{r}
bact_taxa$ASV_ID <- as.character(bact_taxa$ASV_ID)
bact_count$ASV_ID <- as.character(bact_count$ASV_ID)

bact_ASV_data <- left_join(bact_count, bact_taxa,
                           by = c("ASV_ID" = "ASV_ID"))
```


#### Convert to taxmap format

Create a taxmap object using the metacoder package. A taxmap object integrates an ASV or OTU count table with a taxonomy table. This allows us to perform the same manipulations to both tables simultaneously.
```{r}
bact_obj <- parse_tax_data(bact_ASV_data,
                      class_cols = "Taxonomy", # the column that contains taxonomic information
                      class_sep = ";", # The character used to separate taxa in the classification
                      class_regex = "^([a-z]{0,1})_{0,2}(.*)$", # Regex identifying where the data for each taxon is
                      class_key = c(tax_rank = "taxon_rank", # A key describing each regex capture group
                                    tax_name = "taxon_name"))
```

```{r}
print(bact_obj)
```
We have now created a taxmap object that contains an ASV count table (tax_data) and a taxonomy table (class_data). The first line tells us that the ASVs are assigned to 3,720 unique taxa. The second line tells us how the taxa are related to one another in the tree. Note that both tables have a column called "taxon_id" which associates rows in the table to a taxa in the taxonomy.

Create a duplicate of the taxmap bact_obj that we can further manipulate. 
```{r}
bact_obj2 <- bact_obj
```


#### Remove singletons

Remove low-aboundance counts from the tax_data table in the duplicate taxmap object by setting all counts with less than 2 reads (i.e., singletons) to zero.
```{r}
bact_obj2$data$tax_data <- zero_low_counts(bact_obj2, data = "tax_data", min_count = 2)
```
Found 63,573 counts of less than 2 (out of 2,061,918 counts total).

Now we have ASVs that no longer contain any observations, as we can see with the following.
```{r}
no_reads_bact <- rowSums(bact_obj2$data$tax_data[, sample_data$Sample_ID]) == 0
sum(no_reads_bact)
```

There are now 8,911 ASVs that have no reads. We can remove these ASVs using filter_obs, which is used to filter data associated with a taxonomy in a taxmap object. One of the advantages of integrating the ASV count table and taxonomy table into a taxmap object is that the ASVs with no reads can be filtered out of both tables at the same time.
```{r}
bact_obj2 <- filter_obs(bact_obj2, data = "tax_data", ! no_reads_bact, drop_taxa = TRUE)
```

```{r}
print(bact_obj2)
```
We can see that the number of rows decreased in both the tax_data (i.e., ASV counts) and the class_data (i.e., taxonomy) tables. Specifically, the tax_data table now has 8,911 fewer rows than it did previously.


#### Account for un-even sampling 
To account for un-even sampling, convert counts to proportions and add the results to the taxmap object in a new table called "ASV_props". Rarefaction is another popular method for normalization, but the large downside is that it can result in discarding a lot of data.
```{r}
bact_obj2$data$ASV_props <- calc_obs_props(bact_obj2, "tax_data")
```

```{r}
print(bact_obj2$data$ASV_props)
```


#### Get per-taxon information
We currently have values for the abundance of each ASV, but not each taxon. To get information on the taxa, sum the abundance per-taxon and add the results to the taxmap object in a new table called "tax_abund". 
```{r}
bact_obj2$data$tax_abund <- calc_taxon_abund(bact_obj2, "tax_data",
                                             cols = sample_data$Sample_ID)
```

Calculate the number of samples that have reads for each taxon.
```{r}
bact_obj2$data$tax_occ <- calc_n_samples(bact_obj2, "tax_abund", 
                                         groups = sample_data$Management_Type, 
                                         cols = sample_data$Sample_ID)
```
 
```{r}
print(bact_obj2)
```
 


